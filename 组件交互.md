### 组件交互

#### @Input(alias)
```typescript
// 可以对输入的值做判断，用set
  @Input()
  set name(name: string) {
    this._name = (name && name.trim()) || '<no name set>';
  }

  get name(): string { return this._name; }

```
如果你是想直接在 Dom 元素上给 @Input 绑定的元素赋值， 需要引号里在嵌套引号
```typescript
@Input()
appHeroColor: string;  

// 通过 Dom 元素就可以给 appHeroColor 赋值
// <p [appHeroColor]="'blue'"> hero-directive works!

```


#### 父组件调用 @ViewChild() 获取子组件
```typescript
// 需要导入
import { CountdownTimerComponent }  from './countdown-timer.component';

// 用@ViewChild() 声明下
@ViewChild(CountdownTimerComponent)
  private timerComponent: CountdownTimerComponent;
```


#### #data 通过引用变量

#### 父组件和子组件通过服务来通讯
> 在一个服务的变量的作用域是 module 所以用 @Injectable() 完全是可以实现的。

#### 指令
* 属性指令
```html
<!-- 这两种方式都是可以的，但是为何不能加 []  -->
<app-hero-directive appHeroColor></app-hero-directive>
<p appHeroColor></p>

```
ElementRef 不能获取到<app-hero-directive>

* 结构型指令
> 1. 每个宿主只能有一个机构型指令。
  1. 模板引用变量： #nav 声明后可以在模板任意位置使用。
  2. <ng-template> 是 angular 的一个元素，用来渲染 HTML。它不会显示出来，即便你自己在 template 中写入。结构指令会让 <ng-template> 正常工作
  3. <ng-container> 把一些兄弟元素归为一组，可以用这个元素代替 span、div 这类的元素，在页面中不会被渲染，作用和 span 一样。避免 css 污染
    1. 在<select> 渲染中排除某一个 option 的值，因为在 select 中不能使用其他的元素（span， div）这类的元素来排除
    ```html
    <select [(ngModel)]="hero">
      <ng-container *ngFor="let h of heroes">
        <ng-container *ngIf="showSad || h.emotion !== 'sad'">
          <option [ngValue]="h">{{h.name}} ({{h.emotion}})</option>
        </ng-container>
      </ng-container>
    </select>

    ```


  #### 不明确的地方
  * directive 没有办法导入到子 module 里


